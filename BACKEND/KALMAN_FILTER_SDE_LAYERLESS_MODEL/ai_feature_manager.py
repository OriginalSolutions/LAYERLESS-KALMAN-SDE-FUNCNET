# plik: ai_feature_manager.py
# WERSJA: 23.1
# Ten modu≈Ç definiuje dedykowanego managera do obs≈Çugi pliku HDF5
# zawierajƒÖcego cechy wygenerowane przez model analityczny (AI Features).

import h5py
import numpy as np
import logging
import datetime
import time
from pathlib import Path
from typing import Dict, Any, List

class AIFeatureHDF5Manager:
    """ZarzƒÖdza zapisem i odczytem cech AI do/z dedykowanego pliku ai_features.h5."""

    def __init__(self, config: Any, ai_feature_columns: List[str]):
        """
        Inicjalizuje managera cech AI.
        
        Args:
            config: Obiekt konfiguracyjny (u≈ºywany do ≈õcie≈ºki i logowania).
            ai_feature_columns: Lista nazw kolumn cech AI, kt√≥re majƒÖ byƒá przechowywane.
        """
        self.config = config
        self.logger = logging.getLogger(self.__class__.__name__)
        # Domy≈õlna ≈õcie≈ºka mo≈ºe byƒá nadpisana przez konfiguracjƒô analityka
        self.filename = getattr(config, 'ai_features_path', f"{config.system_data_directory}/ai_features.h5")
        self.ai_feature_columns = ai_feature_columns
        self._initialize_database()

    def _initialize_database(self):
        """Tworzy plik HDF5 z odpowiednimi datasetami, je≈õli nie istnieje."""
        if Path(self.filename).exists():
            self.logger.info(f"‚úÖ Kontynuujƒô zapis do istniejƒÖcej bazy cech AI: {self.filename}")
            return
            
        self.logger.info(f"üõ†Ô∏è Tworzenie nowej bazy danych dla cech AI w: {self.filename}")
        with h5py.File(self.filename, 'w') as f:
            f.attrs['creation_date'] = str(datetime.datetime.now())
            f.attrs['description'] = "Storage for features generated by the offline analyzer model."
            
            comp_settings = {'compression': 'gzip', 'chunks': True}
            
            # Kluczowy dataset do synchronizacji
            f.create_dataset('timestamps', (0,), maxshape=(None,), dtype='int64', **comp_settings)
            
            # Tworzenie dataset√≥w dla ka≈ºdej cechy AI
            for name in self.ai_feature_columns:
                f.create_dataset(name, (0,), maxshape=(None,), dtype='float64', **comp_settings)

    def _execute_with_retry(self, operation, operation_name: str):
        """Wykonuje operacjƒô na pliku HDF5 z mechanizmem ponawiania pr√≥b w razie blokady."""
        max_retries, retry_delay = 5, 0.2
        for attempt in range(max_retries):
            try:
                with h5py.File(self.filename, 'a') as f:
                    return operation(f)
            except (OSError, BlockingIOError) as e:
                if hasattr(e, 'errno') and e.errno == 11 and attempt < max_retries-1:
                    self.logger.warning(f"Plik HDF5 cech AI zablokowany ({operation_name}). Pr√≥ba {attempt+2}/{max_retries}...")
                    time.sleep(retry_delay * (attempt + 1))
                else:
                    self.logger.error(f"‚ùå Nie uda≈Ço siƒô wykonaƒá '{operation_name}' na pliku cech AI. B≈ÇƒÖd: {e}", exc_info=True)
                    return None
            except Exception as e:
                self.logger.error(f"‚ùå Nieoczekiwany b≈ÇƒÖd podczas '{operation_name}' na pliku cech AI: {e}", exc_info=True)
                return None

    def _find_or_create_index(self, f: h5py.File, timestamp_ms: int) -> int:
        """Znajduje indeks dla danego timestampu lub tworzy nowy wiersz."""
        timestamps_arr = f['timestamps'][:]
        indices = np.where(timestamps_arr == timestamp_ms)[0]
        if len(indices) > 0:
            return indices[0]
        else:
            n = f['timestamps'].shape[0]
            for dset_name in f.keys():
                f[dset_name].resize((n + 1,))
            f['timestamps'][-1] = timestamp_ms
            # Inicjalizuj nowe warto≈õci jako NaN, aby wiedzieƒá, ≈ºe nie zosta≈Çy jeszcze wype≈Çnione
            for dset_name in self.ai_feature_columns:
                f[dset_name][-1] = np.nan
            return n

    def save_features(self, timestamp_ms: int, features: Dict[str, float]):
        """Zapisuje s≈Çownik cech AI dla danego timestampu (metoda dla analityka)."""
        def op(f):
            idx = self._find_or_create_index(f, timestamp_ms)
            for key, value in features.items():
                if key in f:
                    f[key][idx] = value
                else:
                    self.logger.warning(f"Pr√≥ba zapisu nieznanej cechy AI '{key}'. Kolumna nie istnieje w pliku.")
        
        self._execute_with_retry(op, "zapis cech AI")

    def get_all_data_for_features(self, lookback_minutes: int) -> Dict[str, np.ndarray]:
        """Pobiera wszystkie dane z okre≈õlonego okna czasowego (metoda dla g≈Ç√≥wnego modelu)."""
        def op(f):
            n = f['timestamps'].shape[0]
            if n == 0: return {}
            # Przelicz lookback na liczbƒô wierszy (zak≈ÇadajƒÖc interwa≈Ç 1-minutowy)
            start_idx = max(0, n - lookback_minutes)
            return {name: f[name][start_idx:] for name in f.keys()}
            
        return self._execute_with_retry(op, "pobranie cech AI") or {}
###  END
